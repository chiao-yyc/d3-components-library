# CLI 工具開發指南

## 概述

這份文件詳細說明如何建立和實作 D3 Components CLI 工具，讓使用者可以透過 `npx d3-components add bar-chart` 等命令來管理組件。

## 基礎概念

### 什麼是 CLI 工具？
CLI (Command Line Interface) 工具是可以在終端機中執行的程式。當你執行 `npx d3-components add bar-chart` 時：

1. `npx` 會下載並執行 `d3-components` 包
2. CLI 工具解析 `add bar-chart` 命令
3. 執行對應的邏輯（下載組件檔案）

### NPX 的運作原理
```bash
npx package-name command
# npx 會：
# 1. 檢查 package-name 是否已安裝
# 2. 如果沒有，臨時下載到快取
# 3. 執行 package.json 中 bin 指定的檔案
# 4. 執行完畢後清理快取
```

## 專案架構

### CLI 專案結構
```
packages/cli/
├── package.json           # CLI 套件配置
├── tsconfig.json         # TypeScript 配置
├── src/
│   ├── index.ts          # CLI 入口點
│   ├── commands/         # 各種命令實作
│   │   ├── add.ts        # add 命令
│   │   ├── init.ts       # init 命令
│   │   ├── import.ts     # import 命令
│   │   └── list.ts       # list 命令
│   ├── utils/            # 工具函數
│   │   ├── registry.ts   # Registry API
│   │   ├── project.ts    # 專案管理
│   │   ├── cache.ts      # 快取機制
│   │   └── templates.ts  # 模板處理
│   └── types/            # 型別定義
│       └── index.ts
├── templates/            # 組件模板
│   └── component.tsx.hbs
└── dist/                 # 建構輸出
    └── index.js
```

## 步驟一：專案初始化

### 1. 建立 CLI 專案
```bash
mkdir packages/cli
cd packages/cli
npm init -y
```

### 2. 配置 package.json
```json
{
  "name": "d3-components-cli",
  "version": "1.0.0",
  "description": "D3 Components CLI tool",
  "main": "dist/index.js",
  "bin": {
    "d3-components": "./dist/index.js"
  },
  "files": [
    "dist/**/*",
    "templates/**/*"
  ],
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "test": "jest",
    "prepublishOnly": "npm run build"
  },
  "dependencies": {
    "commander": "^11.0.0",      # 命令行解析
    "inquirer": "^9.0.0",        # 互動式命令行
    "chalk": "^5.0.0",           # 彩色輸出
    "ora": "^7.0.0",             # 載入動畫
    "fs-extra": "^11.0.0",       # 檔案系統操作
    "axios": "^1.0.0",           # HTTP 請求
    "handlebars": "^4.7.0",      # 模板引擎
    "semver": "^7.0.0"           # 版本比較
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/fs-extra": "^11.0.0",
    "@types/inquirer": "^9.0.0",
    "typescript": "^5.0.0",
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "engines": {
    "node": ">=16"
  },
  "keywords": [
    "d3",
    "components",
    "cli",
    "visualization"
  ]
}
```

**重要說明：**
- `bin` 欄位定義了可執行檔案的位置
- `files` 欄位指定發布時包含的檔案
- `prepublishOnly` 確保發布前先建構

### 3. TypeScript 配置
```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

## 步驟二：CLI 入口點

### src/index.ts
```typescript
#!/usr/bin/env node

import { Command } from 'commander'
import chalk from 'chalk'
import { addCommand } from './commands/add'
import { initCommand } from './commands/init'
import { importCommand } from './commands/import'
import { listCommand } from './commands/list'

const program = new Command()

// 基本資訊
program
  .name('d3-components')
  .description('D3 Components CLI - 透明化的 D3 組件庫')
  .version('1.0.0')

// 註冊命令
program
  .command('add <component>')
  .description('添加組件到專案中')
  .option('-v, --variant <variant>', '選擇組件變體')
  .option('-d, --dir <directory>', '目標目錄', './src/components/ui')
  .option('--dry-run', '預覽變更但不實際執行')
  .action(addCommand)

program
  .command('init')
  .description('初始化 D3 Components 專案')
  .option('-t, --template <template>', '專案模板', 'react')
  .action(initCommand)

program
  .command('import <file>')
  .description('匯入資料並生成圖表')
  .option('-c, --chart <type>', '圖表類型')
  .option('--auto-detect', '自動偵測資料格式')
  .option('--interactive', '互動式配置')
  .action(importCommand)

program
  .command('list')
  .description('列出所有可用組件')
  .option('-f, --filter <filter>', '過濾組件')
  .action(listCommand)

program
  .command('update <component>')
  .description('更新指定組件')
  .action(updateCommand)

// 錯誤處理
program.on('command:*', () => {
  console.error(chalk.red(`未知命令: ${program.args.join(' ')}`))
  console.log(chalk.yellow('執行 d3-components --help 查看可用命令'))
  process.exit(1)
})

// 解析命令行參數
program.parse()

// 如果沒有提供任何命令，顯示幫助
if (!process.argv.slice(2).length) {
  program.outputHelp()
}
```

**重要說明：**
- `#!/usr/bin/env node` 是 shebang，告訴系統用 Node.js 執行此檔案
- `commander` 是最受歡迎的 Node.js CLI 框架
- 每個 `.command()` 定義一個子命令

## 步驟三：實作 Add 命令

### src/commands/add.ts
```typescript
import fs from 'fs-extra'
import path from 'path'
import chalk from 'chalk'
import ora from 'ora'
import inquirer from 'inquirer'
import { fetchComponentConfig, downloadComponentFiles } from '../utils/registry'
import { validateProject, updateProjectConfig } from '../utils/project'
import { processTemplateFiles } from '../utils/templates'

interface AddOptions {
  variant?: string
  dir?: string
  dryRun?: boolean
}

export async function addCommand(
  componentName: string,
  options: AddOptions
) {
  const spinner = ora()
  
  try {
    // 1. 顯示開始訊息
    console.log(chalk.blue(`📦 正在添加 ${componentName} 組件...`))
    
    // 2. 驗證專案環境
    spinner.start('檢查專案環境...')
    await validateProject()
    spinner.succeed('專案環境檢查完成')
    
    // 3. 從 registry 獲取組件配置
    spinner.start('獲取組件資訊...')
    const component = await fetchComponentConfig(componentName)
    if (!component) {
      spinner.fail(`找不到組件: ${componentName}`)
      console.log(chalk.yellow('執行 d3-components list 查看可用組件'))
      return
    }
    spinner.succeed('組件資訊獲取成功')
    
    // 4. 選擇變體
    const variant = await selectVariant(component, options.variant)
    
    // 5. 檢查依賴
    await checkDependencies(component.dependencies)
    
    // 6. 確認目標目錄
    const targetDir = path.resolve(options.dir || './src/components/ui')
    await ensureDirectory(targetDir)
    
    // 7. 預覽模式
    if (options.dryRun) {
      console.log(chalk.yellow('🔍 預覽模式 - 不會實際建立檔案'))
      previewChanges(component, variant, targetDir)
      return
    }
    
    // 8. 下載並安裝組件
    spinner.start('下載組件檔案...')
    await downloadAndInstallComponent(component, variant, targetDir)
    spinner.succeed('組件檔案下載完成')
    
    // 9. 更新專案配置
    await updateProjectConfig(component, variant)
    
    // 10. 顯示成功訊息和使用說明
    showSuccessMessage(component, targetDir)
    
  } catch (error) {
    spinner.fail('添加組件失敗')
    console.error(chalk.red(`錯誤: ${error.message}`))
    
    if (process.env.DEBUG) {
      console.error(error.stack)
    }
    
    process.exit(1)
  }
}

async function selectVariant(
  component: ComponentConfig, 
  requestedVariant?: string
): Promise<string> {
  // 如果只有一個變體或已指定變體
  if (component.variants.length === 1 || requestedVariant) {
    const variant = requestedVariant || component.variants[0]
    if (!component.variants.includes(variant)) {
      throw new Error(`變體 "${variant}" 不存在於組件 "${component.name}"`)
    }
    return variant
  }
  
  // 互動式選擇變體
  const { variant } = await inquirer.prompt([
    {
      type: 'list',
      name: 'variant',
      message: '選擇組件變體:',
      choices: component.variants.map(v => ({
        name: `${v} - ${component.variantDescriptions?.[v] || ''}`,
        value: v
      }))
    }
  ])
  
  return variant
}

async function checkDependencies(deps: string[]) {
  if (!deps.length) return
  
  const packageJsonPath = path.resolve('./package.json')
  const packageJson = await fs.readJSON(packageJsonPath)
  
  const allDeps = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies
  }
  
  const missing = deps.filter(dep => !allDeps[dep])
  
  if (missing.length > 0) {
    console.log(chalk.yellow(`⚠️  缺少依賴: ${missing.join(', ')}`))
    
    const { install } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'install',
        message: '是否要安裝缺少的依賴？',
        default: true
      }
    ])
    
    if (install) {
      await installDependencies(missing)
    } else {
      console.log(chalk.yellow('請手動安裝依賴，否則組件可能無法正常運作'))
    }
  }
}

async function installDependencies(deps: string[]) {
  const { execSync } = require('child_process')
  
  // 偵測套件管理器
  const packageManager = detectPackageManager()
  
  const spinner = ora(`使用 ${packageManager} 安裝依賴...`).start()
  
  try {
    const installCmd = {
      npm: `npm install ${deps.join(' ')}`,
      yarn: `yarn add ${deps.join(' ')}`,
      pnpm: `pnpm add ${deps.join(' ')}`
    }[packageManager]
    
    execSync(installCmd, { stdio: 'ignore' })
    spinner.succeed('依賴安裝完成')
  } catch (error) {
    spinner.fail('依賴安裝失敗')
    throw new Error('請手動安裝缺少的依賴')
  }
}

function detectPackageManager(): 'npm' | 'yarn' | 'pnpm' {
  if (fs.existsSync('pnpm-lock.yaml')) return 'pnpm'
  if (fs.existsSync('yarn.lock')) return 'yarn'
  return 'npm'
}

async function ensureDirectory(dir: string) {
  await fs.ensureDir(dir)
}

async function downloadAndInstallComponent(
  component: ComponentConfig,
  variant: string,
  targetDir: string
) {
  const componentDir = path.join(targetDir, component.name)
  await fs.ensureDir(componentDir)
  
  // 下載所有檔案
  await downloadComponentFiles(component, variant, componentDir)
  
  // 處理模板變數
  await processTemplateFiles(componentDir, {
    componentName: component.name,
    variant,
    timestamp: new Date().toISOString()
  })
}

function previewChanges(
  component: ComponentConfig,
  variant: string,
  targetDir: string
) {
  console.log(chalk.blue('\n📋 預覽變更:'))
  console.log(`組件: ${component.name}`)
  console.log(`變體: ${variant}`)
  console.log(`目標目錄: ${targetDir}`)
  console.log('\n將會建立的檔案:')
  
  component.files.forEach(file => {
    const filePath = path.join(targetDir, component.name, file.name)
    console.log(chalk.green(`  + ${filePath}`))
  })
  
  if (component.dependencies.length > 0) {
    console.log('\n需要的依賴:')
    component.dependencies.forEach(dep => {
      console.log(chalk.yellow(`  • ${dep}`))
    })
  }
}

function showSuccessMessage(component: ComponentConfig, targetDir: string) {
  console.log(chalk.green('\n✅ 組件添加成功!'))
  console.log(chalk.gray(`📁 檔案位置: ${path.join(targetDir, component.name)}`))
  
  // 顯示使用範例
  if (component.example) {
    console.log(chalk.blue('\n📖 使用範例:'))
    console.log(chalk.gray(component.example))
  }
  
  // 顯示相關檔案
  console.log(chalk.blue('\n📄 相關檔案:'))
  component.files.forEach(file => {
    console.log(chalk.gray(`  • ${file.name} - ${file.description || ''}`))
  })
}
```

## 步驟四：Registry 系統

### src/utils/registry.ts
```typescript
import axios from 'axios'
import fs from 'fs-extra'
import path from 'path'
import { getCachedComponent, setCachedComponent } from './cache'

// Registry 配置
const REGISTRY_URL = process.env.D3_COMPONENTS_REGISTRY || 'https://registry.d3-components.com'
const CACHE_TTL = 1000 * 60 * 60 // 1 小時

export interface ComponentConfig {
  name: string
  description: string
  version: string
  dependencies: string[]
  files: FileConfig[]
  variants: string[]
  variantDescriptions?: Record<string, string>
  tags: string[]
  examples?: string[]
  example?: string
}

interface FileConfig {
  name: string
  type: 'component' | 'style' | 'type' | 'test'
  description?: string
}

export async function fetchComponentConfig(
  name: string
): Promise<ComponentConfig | null> {
  try {
    // 先檢查快取
    const cached = await getCachedComponent(name)
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      return cached.data
    }
    
    // 從遠端獲取
    const response = await axios.get(`${REGISTRY_URL}/components/${name}/config.json`, {
      timeout: 10000
    })
    
    const config = response.data
    
    // 更新快取
    await setCachedComponent(name, {
      data: config,
      timestamp: Date.now()
    })
    
    return config
    
  } catch (error) {
    if (error.response?.status === 404) {
      return null // 組件不存在
    }
    
    // 網路錯誤時嘗試使用快取
    const cached = await getCachedComponent(name)
    if (cached) {
      console.warn('使用快取的組件配置（網路連線問題）')
      return cached.data
    }
    
    throw new Error(`無法獲取組件配置: ${error.message}`)
  }
}

export async function downloadComponentFiles(
  component: ComponentConfig,
  variant: string,
  targetDir: string
) {
  for (const file of component.files) {
    const fileUrl = `${REGISTRY_URL}/components/${component.name}/${variant}/${file.name}`
    const filePath = path.join(targetDir, file.name)
    
    try {
      const response = await axios.get(fileUrl, {
        timeout: 30000,
        responseType: 'text'
      })
      
      await fs.writeFile(filePath, response.data, 'utf8')
      
    } catch (error) {
      throw new Error(`下載檔案失敗 ${file.name}: ${error.message}`)
    }
  }
}

export async function listAllComponents(): Promise<ComponentConfig[]> {
  try {
    const response = await axios.get(`${REGISTRY_URL}/index.json`, {
      timeout: 10000
    })
    
    return response.data.components || []
    
  } catch (error) {
    throw new Error(`無法獲取組件列表: ${error.message}`)
  }
}

export async function searchComponents(query: string): Promise<ComponentConfig[]> {
  const allComponents = await listAllComponents()
  
  const searchTerm = query.toLowerCase()
  
  return allComponents.filter(component => {
    return (
      component.name.toLowerCase().includes(searchTerm) ||
      component.description.toLowerCase().includes(searchTerm) ||
      component.tags.some(tag => tag.toLowerCase().includes(searchTerm))
    )
  })
}
```

## 步驟五：專案管理工具

### src/utils/project.ts
```typescript
import fs from 'fs-extra'
import path from 'path'
import chalk from 'chalk'

export async function validateProject() {
  // 檢查是否在有效的專案目錄中
  const packageJsonPath = path.resolve('./package.json')
  
  if (!await fs.pathExists(packageJsonPath)) {
    throw new Error('請在 Node.js 專案根目錄中執行此命令')
  }
  
  // 檢查專案類型
  const packageJson = await fs.readJSON(packageJsonPath)
  
  if (!packageJson.dependencies?.react && !packageJson.devDependencies?.react) {
    console.warn(chalk.yellow('⚠️  偵測到非 React 專案'))
    console.warn(chalk.yellow('    部分功能可能需要手動調整'))
  }
  
  // 檢查 TypeScript 支援
  const hasTypeScript = 
    packageJson.dependencies?.typescript ||
    packageJson.devDependencies?.typescript ||
    await fs.pathExists('./tsconfig.json')
  
  if (!hasTypeScript) {
    console.warn(chalk.yellow('⚠️  未偵測到 TypeScript'))
    console.warn(chalk.yellow('    建議使用 TypeScript 以獲得更好的開發體驗'))
  }
}

export async function updateProjectConfig(
  component: ComponentConfig,
  variant: string
) {
  const configPath = path.resolve('./d3-components.json')
  
  let config = {
    $schema: 'https://registry.d3-components.com/schema.json',
    components: []
  }
  
  if (await fs.pathExists(configPath)) {
    config = await fs.readJSON(configPath)
  }
  
  // 檢查是否已安裝
  const existingIndex = config.components.findIndex(c => c.name === component.name)
  
  const componentEntry = {
    name: component.name,
    variant,
    version: component.version,
    installedAt: new Date().toISOString()
  }
  
  if (existingIndex >= 0) {
    config.components[existingIndex] = componentEntry
  } else {
    config.components.push(componentEntry)
  }
  
  await fs.writeJSON(configPath, config, { spaces: 2 })
}

export async function getInstalledComponents(): Promise<any[]> {
  const configPath = path.resolve('./d3-components.json')
  
  if (!await fs.pathExists(configPath)) {
    return []
  }
  
  const config = await fs.readJSON(configPath)
  return config.components || []
}

export async function isComponentInstalled(name: string): Promise<boolean> {
  const installed = await getInstalledComponents()
  return installed.some(c => c.name === name)
}
```

## 步驟六：建構和發布

### 建構腳本
```bash
# 建構專案
npm run build

# 測試 CLI（本地）
npm link
d3-components --help

# 取消連結
npm unlink
```

### 發布到 NPM
```bash
# 登入 NPM
npm login

# 發布
npm publish

# 指定標籤發布（測試版本）
npm publish --tag beta
```

### 測試發布的套件
```bash
# 測試已發布的版本
npx d3-components@latest --help
```

## 步驟七：開發和除錯

### 本地開發
```bash
# 監視模式建構
npm run dev

# 在另一個終端中測試
node dist/index.js add bar-chart
```

### 除錯技巧
```typescript
// 添加除錯模式
if (process.env.DEBUG) {
  console.log('除錯資訊:', { componentName, options })
}

// 錯誤處理
try {
  // 危險操作
} catch (error) {
  if (process.env.DEBUG) {
    console.error('詳細錯誤:', error.stack)
  } else {
    console.error('錯誤:', error.message)
  }
}
```

### 使用範例
```bash
# 除錯模式
DEBUG=1 npx d3-components add bar-chart

# 預覽模式
npx d3-components add bar-chart --dry-run

# 指定目錄
npx d3-components add bar-chart --dir ./components
```

## 常見問題

### Q: 為什麼需要 `#!/usr/bin/env node`？
A: 這是 shebang，告訴系統用 Node.js 執行此檔案。NPX 會讀取 package.json 的 `bin` 欄位，然後執行對應的檔案。

### Q: 如何處理不同作業系統的相容性？
A: 使用 `path.resolve()` 和 `path.join()` 處理路徑，避免硬編碼分隔符號。

### Q: 如何處理網路連線問題？
A: 實作快取機制，設定適當的 timeout，並提供離線模式。

### Q: 如何測試 CLI 工具？
A: 使用 Jest 測試個別函數，使用 `npm link` 測試整體 CLI 流程。

---

這份指南涵蓋了建立完整 CLI 工具的所有必要知識。按照這些步驟，你就能建立一個功能完整的命令列工具。