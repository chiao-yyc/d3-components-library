import React, { useRef, useEffect, useMemo, useState } from 'react'
import * as d3 from 'd3'
import { cn } from '../../../utils/cn'
import { ResponsiveChartContainer } from '../../primitives/canvas/responsive-chart-container'
import { useOHLCProcessor } from '../../core/ohlc-processor'
import { useColorScheme } from '../../core/color-scheme'
import { useTooltip, getPositionFromEvent } from '../../ui/chart-tooltip'
import { ChartTooltip } from '../../ui/chart-tooltip'
import { 
  CandlestickChartProps, 
  CandlestickItem, 
  VolumeItem, 
  CandlestickScales,
  CandlestickTooltipData
} from './types'

// é è¨­é…ç½®
const DEFAULT_COLORS = {
  tw: { up: '#ef4444', down: '#22c55e', doji: '#6b7280' }, // å°è‚¡ï¼šç´…æ¼²ç¶ è·Œ
  us: { up: '#22c55e', down: '#ef4444', doji: '#6b7280' }, // ç¾è‚¡ï¼šç¶ æ¼²ç´…è·Œ
  custom: { up: '#10b981', down: '#f59e0b', doji: '#6b7280' }
}

export function CandlestickChart({
  data,
  mapping,
  width,
  height,
  responsive,
  margin,
  upColor,
  downColor,
  dojiColor,
  candleWidth = 0.8,
  wickWidth = 1,
  colorMode = 'tw',
  showVolume = true,
  volumeHeightRatio = 0.25,
  showGrid = true,
  showCrosshair = false,
  enableZoom = true,
  enablePan = true,
  animate = true,
  animationDuration = 800,
  interactive = true,
  showTooltip = true,
  tooltipFormat,
  onDataClick,
  onDataHover,
  onCandleClick, // å‘ä¸‹å…¼å®¹
  onCandleHover, // å‘ä¸‹å…¼å®¹
  onDateRangeChange,
  className,
  style,
  ...props
}: CandlestickChartProps) {
  // æ™ºèƒ½éŸ¿æ‡‰å¼æª¢æ¸¬ï¼šå¦‚æœæ˜ç¢ºæŒ‡å®šäº†å°ºå¯¸ï¼Œå‰‡é—œé–‰éŸ¿æ‡‰å¼ï¼›å¦å‰‡é è¨­é–‹å•ŸéŸ¿æ‡‰å¼
  const isResponsive = responsive !== undefined ? responsive : (width === undefined && height === undefined)
  const fallbackWidth = 800
  const fallbackHeight = 500
  const svgRef = useRef<SVGSVGElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const [crosshair, setCrosshair] = useState<{ x: number; y: number } | null>(null)
  // ç§»é™¤è¤‡é›œçš„ SVG æº–å‚™ç‹€æ…‹æª¢æ¸¬

  // è™•ç† OHLC æ•¸æ“š
  const { 
    data: processedData, 
    statistics, 
    errors, 
    warnings,
    resolvedMapping 
  } = useOHLCProcessor(data, {
    mapping,
    autoDetect: true,
    sortByDate: true,
    removeInvalid: true
  })
  
  console.log('OHLC Processor results:', {
    rawDataLength: data?.length,
    processedDataLength: processedData?.length,
    errors,
    warnings,
    firstProcessedItem: processedData?.[0]
  })

  // é¡è‰²é…ç½®
  const colors = useMemo(() => {
    const modeColors = DEFAULT_COLORS[colorMode] || DEFAULT_COLORS.custom
    return {
      up: upColor || modeColors.up,
      down: downColor || modeColors.down,
      doji: dojiColor || modeColors.doji
    }
  }, [upColor, downColor, dojiColor, colorMode])

  // ä½¿ç”¨å›ºå®šé‚Šè·ï¼Œé¿å…è¤‡é›œè¨ˆç®—å°è‡´çš„å•é¡Œ
  const defaultMargin = { top: 20, right: 30, bottom: 40, left: 60 }
  const finalMargin = margin || defaultMargin

  // è¨ˆç®—åœ–è¡¨å°ºå¯¸ - æ·»åŠ å®‰å…¨æª¢æŸ¥ï¼Œé¿å… undefined å€¼
  const safeWidth = width || fallbackWidth
  const safeHeight = height || fallbackHeight
  
  const chartHeight = showVolume 
    ? safeHeight * (1 - volumeHeightRatio) - finalMargin.top - finalMargin.bottom
    : safeHeight - finalMargin.top - finalMargin.bottom
  const volumeHeight = showVolume 
    ? safeHeight * volumeHeightRatio - 10 // 10px gap
    : 0
  const chartWidth = safeWidth - finalMargin.left - finalMargin.right

  // å‰µå»ºæ¯”ä¾‹å°º
  const scales = useMemo((): CandlestickScales | null => {
    if (!processedData.length || chartWidth <= 0 || chartHeight <= 0) return null

    // æ™‚é–“æ¯”ä¾‹å°º - å¢åŠ é‚Šè·ä»¥é¿å…è Ÿç‡­è¢«æˆªæ–·
    const timeExtent = d3.extent(processedData, d => d.date) as [Date, Date]
    const timePadding = (timeExtent[1].getTime() - timeExtent[0].getTime()) * 0.05 // 5% é‚Šè·
    const xScale = d3.scaleTime()
      .domain([
        new Date(timeExtent[0].getTime() - timePadding),
        new Date(timeExtent[1].getTime() + timePadding)
      ])
      .range([0, chartWidth])

    // åƒ¹æ ¼æ¯”ä¾‹å°º
    const allPrices = processedData.flatMap(d => [d.high, d.low])
    const priceExtent = d3.extent(allPrices) as [number, number]
    const yScale = d3.scaleLinear()
      .domain(priceExtent)
      .nice()
      .range([chartHeight, 0])

    // æˆäº¤é‡æ¯”ä¾‹å°º
    let volumeScale: d3.ScaleLinear<number, number> | undefined
    if (showVolume) {
      const volumes = processedData.map(d => d.volume || 0).filter(v => v > 0)
      
      if (volumes.length > 0) {
        const maxVolume = Math.max(...volumes)
        volumeScale = d3.scaleLinear()
          .domain([0, maxVolume])
          .range([volumeHeight, 0])
      }
    }

    return { xScale, yScale, volumeScale }
  }, [processedData, chartWidth, chartHeight, volumeHeight, showVolume])

  // è¨ˆç®—è Ÿç‡­æ•¸æ“š
  const candlesticks = useMemo((): CandlestickItem[] => {
    if (!scales || !processedData.length) return []

    const { xScale, yScale } = scales
    
    // è¨ˆç®—è Ÿç‡­é–“è·ï¼šåŸºæ–¼æ™‚é–“è»¸å¯¦éš›å¯¬åº¦
    const timeRange = xScale.domain()
    const timeDiff = timeRange[1].getTime() - timeRange[0].getTime()
    const avgTimeBetweenPoints = timeDiff / Math.max(1, processedData.length - 1)
    const pixelPerMs = chartWidth / timeDiff
    const availableWidth = avgTimeBetweenPoints * pixelPerMs
    const candleActualWidth = Math.min(availableWidth * candleWidth, chartWidth / processedData.length * 0.8)

    return processedData.map((d, i) => {
      const x = xScale(d.date) - candleActualWidth / 2
      const bodyTop = yScale(Math.max(d.open, d.close))
      const bodyBottom = yScale(Math.min(d.open, d.close))
      const bodyHeight = Math.max(1, bodyBottom - bodyTop) // æœ€å°é«˜åº¦ 1px
      const wickTop = yScale(d.high)
      const wickBottom = yScale(d.low)

      let color = colors.doji
      if (d.direction === 'up') color = colors.up
      else if (d.direction === 'down') color = colors.down

      return {
        data: d,
        geometry: {
          x,
          bodyTop,
          bodyBottom,
          bodyHeight,
          wickTop,
          wickBottom,
          width: candleActualWidth
        },
        color,
        index: i
      }
    })
  }, [scales, processedData, chartWidth, candleWidth, colors])

  // è¨ˆç®—æˆäº¤é‡æ•¸æ“š
  const volumes = useMemo((): VolumeItem[] => {
    if (!scales?.volumeScale || !showVolume || !processedData.length) return []

    const { xScale, volumeScale } = scales
    
    // ä½¿ç”¨èˆ‡candlestickç›¸åŒçš„å¯¬åº¦è¨ˆç®—é‚è¼¯
    const timeRange = xScale.domain()
    const timeDiff = timeRange[1].getTime() - timeRange[0].getTime()
    const avgTimeBetweenPoints = timeDiff / Math.max(1, processedData.length - 1)
    const pixelPerMs = chartWidth / timeDiff
    const availableWidth = avgTimeBetweenPoints * pixelPerMs
    const volumeBarWidth = Math.min(availableWidth * 0.6, chartWidth / processedData.length * 0.6)

    return processedData.map((d, i) => {
      if (!d.volume) return null

      const x = xScale(d.date) - volumeBarWidth / 2
      const scaledY = volumeScale(d.volume)  // 0 åˆ° volumeHeight
      const barHeight = volumeHeight - scaledY  // å¯¦éš›baré«˜åº¦
      const y = scaledY  // barçš„é ‚éƒ¨ä½ç½®

      // ç›´æ¥æ ¹æ“šæ•¸æ“šæ–¹å‘æ±ºå®šé¡è‰²ï¼Œä¸ä¾è³´candlesticks
      let color = colors.doji
      if (d.direction === 'up') color = colors.up
      else if (d.direction === 'down') color = colors.down

      return {
        data: d,
        geometry: {
          x,
          y,
          width: volumeBarWidth,
          height: barHeight
        },
        color,
        index: i
      }
    }).filter(Boolean) as VolumeItem[]
  }, [scales, showVolume, processedData, chartWidth, volumeHeight, colors])

  // Tooltip åŠŸèƒ½
  const { tooltip, showTooltip: showTooltipFn, hideTooltip } = useTooltip({
    hideDelay: 100
  })

  // æ ¼å¼åŒ– tooltip å…§å®¹
  const formatTooltipContent = (candlestick: CandlestickItem): React.ReactNode => {
    const { data: d } = candlestick
    
    if (tooltipFormat) {
      return tooltipFormat(d)
    }

    const formatNumber = (num: number) => num.toLocaleString(undefined, { 
      minimumFractionDigits: 2, 
      maximumFractionDigits: 2 
    })
    
    const formatPercent = (num: number) => {
      const sign = num >= 0 ? '+' : ''
      return `${sign}${num.toFixed(2)}%`
    }

    return (
      <div className="space-y-1">
        <div className="font-semibold">{d.date.toLocaleDateString()}</div>
        <div className="grid grid-cols-2 gap-2 text-sm">
          <div>é–‹ç›¤: {formatNumber(d.open)}</div>
          <div>æ”¶ç›¤: {formatNumber(d.close)}</div>
          <div>æœ€é«˜: {formatNumber(d.high)}</div>
          <div>æœ€ä½: {formatNumber(d.low)}</div>
        </div>
        <div className="text-sm border-t pt-1">
          <div>æ¼²è·Œ: {formatNumber(d.change)} ({formatPercent(d.changePercent)})</div>
          {d.volume && <div>æˆäº¤é‡: {d.volume.toLocaleString()}</div>}
        </div>
      </div>
    )
  }

  // D3 æ¸²æŸ“ - ä½¿ç”¨å»¶é²æª¢æ¸¬ç¢ºä¿ SVG å…ƒç´ å°±ç·’
  useEffect(() => {
    const renderChart = () => {
      console.log('CandlestickChart render check:', {
        svgRef: !!svgRef.current,
        scales: !!scales,
        candlesticksLength: candlesticks.length,
        processedDataLength: processedData.length,
        chartWidth,
        chartHeight
      })
      
      if (!svgRef.current || !scales || !candlesticks.length) {
        console.log('CandlestickChart early return - missing requirements')
        return
      }
      
      console.log('CandlestickChart proceeding with rendering...')

    const svg = d3.select(svgRef.current)
    svg.selectAll('*').remove()

    // ä¸»è¦ç¹ªåœ–å€åŸŸ
    const g = svg.append('g')
      .attr('transform', `translate(${finalMargin.left}, ${finalMargin.top})`)

    const { xScale, yScale, volumeScale } = scales

    // ç¹ªè£½æ ¼ç·š
    if (showGrid) {
      // æ°´å¹³æ ¼ç·š
      g.append('g')
        .attr('class', 'grid-horizontal')
        .selectAll('line')
        .data(yScale.ticks())
        .enter()
        .append('line')
        .attr('x1', 0)
        .attr('x2', chartWidth)
        .attr('y1', d => yScale(d))
        .attr('y2', d => yScale(d))
        .attr('stroke', '#e5e7eb')
        .attr('stroke-width', 0.5)
        .attr('opacity', 0.5)

      // å‚ç›´æ ¼ç·š
      const timeTickCount = Math.min(10, Math.floor(chartWidth / 80))
      g.append('g')
        .attr('class', 'grid-vertical')
        .selectAll('line')
        .data(xScale.ticks(timeTickCount))
        .enter()
        .append('line')
        .attr('x1', d => xScale(d))
        .attr('x2', d => xScale(d))
        .attr('y1', 0)
        .attr('y2', chartHeight)
        .attr('stroke', '#e5e7eb')
        .attr('stroke-width', 0.5)
        .attr('opacity', 0.5)
    }

    // ç¹ªè£½è Ÿç‡­åœ–
    const candleGroups = g.selectAll('.candlestick')
      .data(candlesticks)
      .enter()
      .append('g')
      .attr('class', 'candlestick')
      .style('cursor', interactive ? 'pointer' : 'default')

    // å½±ç·š
    candleGroups.append('line')
      .attr('class', 'wick')
      .attr('x1', d => d.geometry.x + d.geometry.width / 2)
      .attr('x2', d => d.geometry.x + d.geometry.width / 2)
      .attr('y1', d => d.geometry.wickTop)
      .attr('y2', d => d.geometry.wickBottom)
      .attr('stroke', d => d.color)
      .attr('stroke-width', wickWidth)

    // å¯¦é«” - å€åˆ†ä¸Šæ¼²ï¼ˆç©ºå¿ƒï¼‰å’Œä¸‹è·Œï¼ˆå¯¦å¿ƒï¼‰
    const bodies = candleGroups.append('rect')
      .attr('class', 'body')
      .attr('x', d => d.geometry.x)
      .attr('y', d => d.geometry.bodyTop)
      .attr('width', d => d.geometry.width)
      .attr('height', d => d.geometry.bodyHeight)
      .attr('fill', d => {
        // ä¸Šæ¼²è Ÿç‡­ä½¿ç”¨ç©ºå¿ƒï¼ˆç™½è‰²å¡«å……ï¼‰ï¼Œä¸‹è·Œè Ÿç‡­ä½¿ç”¨å¯¦å¿ƒ
        if (d.data.direction === 'up') {
          return colorMode === 'tw' ? '#ffffff' : '#ffffff'
        }
        return d.color
      })
      .attr('stroke', d => d.color)
      .attr('stroke-width', 1)

    // æš«æ™‚ç§»é™¤å‹•ç•«æ•ˆæœï¼Œé¿å…opacityå•é¡Œ
    // if (animate) {
    //   bodies
    //     .style('opacity', 0)
    //     .transition()
    //     .duration(animationDuration)
    //     .delay((d, i) => i * 20)
    //     .ease(d3.easeQuadOut)
    //     .style('opacity', 1)
    // }

    // æˆäº¤é‡åœ–è¡¨
    if (showVolume && volumeScale && volumes.length) {
      const volumeG = svg.append('g')
        .attr('transform', `translate(${finalMargin.left}, ${safeHeight - finalMargin.bottom - volumeHeight})`)

      volumeG.selectAll('.volume-bar')
        .data(volumes)
        .enter()
        .append('rect')
        .attr('class', 'volume-bar')
        .attr('x', d => d.geometry.x)
        .attr('y', d => d.geometry.y)
        .attr('width', d => d.geometry.width)
        .attr('height', d => d.geometry.height)
        .attr('fill', d => d.color)
        .attr('opacity', 0.6)

      // æˆäº¤é‡ Y è»¸
      volumeG.append('g')
        .attr('class', 'volume-axis')
        .call(d3.axisLeft(volumeScale).ticks(3))
        .selectAll('text')
        .style('font-size', '10px')
        .style('fill', '#6b7280')
    }

    // äº’å‹•äº‹ä»¶
    if (interactive) {
      candleGroups
        .on('mouseenter', function(event, d) {
          // æš«æ™‚è¨»è§£æ‰hoverè¦–è¦ºæ•ˆæœï¼Œåªä¿ç•™tooltipå’Œå›èª¿
          // d3.select(this).select('.body')
          //   .attr('stroke-width', 2)
          // d3.select(this).select('.wick')
          //   .attr('stroke-width', wickWidth * 1.5)
          
          if (showTooltip) {
            const position = getPositionFromEvent(event)
            showTooltipFn(position, { data: d.data, series: 'Candlestick' })
          }
          
          // å„ªå…ˆä½¿ç”¨æ–°çš„æ¨™æº–å‘½åï¼Œå†å›é€€åˆ°èˆŠå‘½å
          (onDataHover || onCandleHover)?.(d.data)
        })
        .on('mouseleave', function() {
          // æš«æ™‚è¨»è§£æ‰hoverè¦–è¦ºæ•ˆæœæ¢å¾©
          // d3.select(this).select('.body')
          //   .attr('stroke-width', 1)
          // d3.select(this).select('.wick')
          //   .attr('stroke-width', wickWidth)
          hideTooltip()
          (onDataHover || onCandleHover)?.(null)
        })
        .on('click', function(event, d) {
          // å„ªå…ˆä½¿ç”¨æ–°çš„æ¨™æº–å‘½åï¼Œå†å›é€€åˆ°èˆŠå‘½å
          (onDataClick || onCandleClick)?.(d.data)
        })
    }

    // ç¹ªè£½åæ¨™è»¸
    // Xè»¸ï¼ˆæ™‚é–“ï¼‰
    const timeTickCount = Math.min(8, Math.floor(chartWidth / 100))
    g.append('g')
      .attr('class', 'x-axis')
      .attr('transform', `translate(0, ${chartHeight})`)
      .call(d3.axisBottom(xScale).ticks(timeTickCount).tickFormat(d3.timeFormat('%m/%d')))
      .selectAll('text')
      .style('font-size', '12px')
      .style('fill', '#6b7280')

    // Yè»¸ï¼ˆåƒ¹æ ¼ï¼‰
    g.append('g')
      .attr('class', 'y-axis')
      .call(d3.axisLeft(yScale))
      .selectAll('text')
      .style('font-size', '12px')
      .style('fill', '#6b7280')

    // è»¸ç·šæ¨£å¼
    g.selectAll('.domain')
      .style('stroke', '#d1d5db')
    
      g.selectAll('.tick line')
        .style('stroke', '#e5e7eb')
    }

    // å˜—è©¦ç«‹å³æ¸²æŸ“ï¼Œå¦‚æœ SVG ref ä¸å¯ç”¨å‰‡å»¶é²åŸ·è¡Œ
    if (svgRef.current) {
      renderChart()
    } else {
      // å»¶é²åŸ·è¡Œä»¥ç­‰å¾… SVG å…ƒç´ æ›è¼‰
      const timeoutId = setTimeout(renderChart, 50)
      return () => clearTimeout(timeoutId)
    }
  }, [
    candlesticks, volumes, scales, chartWidth, chartHeight, volumeHeight, 
    showGrid, showVolume, animate, animationDuration, interactive, wickWidth,
    finalMargin, safeHeight, showTooltip, showTooltipFn, hideTooltip, onCandleClick, onCandleHover
  ])

  // éŒ¯èª¤ç‹€æ…‹
  if (errors.length > 0) {
    return (
      <div className={cn('candlestick-chart-container', className)} style={style} {...props}>
        <div className="error-state p-4 bg-red-50 border border-red-200 rounded">
          <h3 className="text-red-800 font-semibold">æ•¸æ“šè™•ç†éŒ¯èª¤</h3>
          <ul className="text-red-600 text-sm mt-2">
            {errors.map((error, i) => (
              <li key={i}>â€¢ {error}</li>
            ))}
          </ul>
        </div>
      </div>
    )
  }

  // ç©ºæ•¸æ“šç‹€æ…‹
  if (!processedData.length) {
    return (
      <div className={cn('candlestick-chart-container', className)} style={style} {...props}>
        <div className="empty-state text-center py-8">
          <p className="text-gray-500">ç„¡ Kç·š è³‡æ–™å¯é¡¯ç¤º</p>
          {warnings.length > 0 && (
            <ul className="text-yellow-600 text-sm mt-2">
              {warnings.map((warning, i) => (
                <li key={i}>â€¢ {warning}</li>
              ))}
            </ul>
          )}
        </div>
      </div>
    )
  }

  // éŸ¿æ‡‰å¼åœ–è¡¨å…§å®¹æ¸²æŸ“å™¨
  const renderCandlestickChart = (chartWidth: number, chartHeight: number) => {
    console.log('ğŸ¯ renderCandlestickChart called with dimensions:', { chartWidth, chartHeight })
    
    return (
    <div 
      ref={containerRef}
      className={cn('candlestick-chart-container relative', className)}
      style={style}
      {...props}
    >
      {/* ä¸»è¦åœ–è¡¨ */}
      <svg
        ref={svgRef}
        width={chartWidth}
        height={chartHeight}
        viewBox={`0 0 ${chartWidth} ${chartHeight}`}
        className="candlestick-chart-svg overflow-visible max-w-full h-auto"
        preserveAspectRatio="xMidYMid meet"
      />

      {/* çµ±è¨ˆè³‡è¨Šé¡¯ç¤º */}
      <div className="absolute top-2 right-2 bg-white bg-opacity-90 p-2 rounded shadow text-xs">
        <div>æ•¸æ“šé»: {statistics.count}</div>
        <div>æœŸé–“: {statistics.dateRange.start.toLocaleDateString()} - {statistics.dateRange.end.toLocaleDateString()}</div>
        <div>åƒ¹æ ¼ç¯„åœ: {statistics.priceRange.min.toFixed(2)} - {statistics.priceRange.max.toFixed(2)}</div>
        {statistics.totalVolume && (
          <div>ç¸½æˆäº¤é‡: {statistics.totalVolume.toLocaleString()}</div>
        )}
      </div>

      {/* Tooltip */}
      <ChartTooltip
        visible={tooltip.visible && tooltip.data != null}
        position={tooltip.position}
        content={
          tooltip.data && candlesticks.length > 0 
            ? formatTooltipContent(candlesticks.find(c => c.data === tooltip.data.data) || candlesticks[0])
            : null
        }
        theme="dark"
        className="max-w-xs"
      />

      {/* è­¦å‘Šè¨Šæ¯ */}
      {warnings.length > 0 && (
        <div className="absolute bottom-2 left-2 bg-yellow-50 border border-yellow-200 rounded p-2 text-xs">
          {warnings.map((warning, i) => (
            <div key={i} className="text-yellow-800">âš  {warning}</div>
          ))}
        </div>
      )}
    </div>
    )
  }

  // éŸ¿æ‡‰å¼æ¨¡å¼
  if (isResponsive) {
    return (
      <ResponsiveChartContainer>
        {({ width: containerWidth, height: containerHeight }) => 
          renderCandlestickChart(containerWidth, containerHeight)
        }
      </ResponsiveChartContainer>
    )
  }

  // å›ºå®šå°ºå¯¸æ¨¡å¼
  return renderCandlestickChart(width || fallbackWidth, height || fallbackHeight)
}