import React, { useEffect, useRef, useMemo } from 'react'
import * as d3 from 'd3'

export interface WaterfallShapeData {
  x: any
  value: number
  type?: 'positive' | 'negative' | 'total' | 'subtotal'
  label?: string
  category?: string
  [key: string]: any
}

export interface WaterfallProps {
  data: WaterfallShapeData[]
  xScale: any
  yScale: any
  className?: string
  animate?: boolean
  animationDuration?: number
  positiveColor?: string
  negativeColor?: string
  totalColor?: string
  subtotalColor?: string
  opacity?: number
  strokeWidth?: number
  strokeColor?: string
  showConnectors?: boolean
  connectorColor?: string
  connectorWidth?: number
  connectorDasharray?: string
  onBarClick?: (dataPoint: WaterfallShapeData, cumulativeValue: number, event: React.MouseEvent) => void
  onBarMouseEnter?: (dataPoint: WaterfallShapeData, cumulativeValue: number, event: React.MouseEvent) => void
  onBarMouseLeave?: (dataPoint: WaterfallShapeData, cumulativeValue: number, event: React.MouseEvent) => void
}

export const Waterfall: React.FC<WaterfallProps> = ({
  data,
  xScale,
  yScale,
  className = '',
  animate = true,
  animationDuration = 300,
  positiveColor = '#10b981',
  negativeColor = '#ef4444',
  totalColor = '#3b82f6',
  subtotalColor = '#8b5cf6',
  opacity = 0.8,
  strokeWidth = 1,
  strokeColor = 'white',
  showConnectors = true,
  connectorColor = '#6b7280',
  connectorWidth = 1,
  connectorDasharray = '3,3',
  onDataClick,
  onDataHover,
  onBarClick,
  onBarMouseEnter,
  onBarMouseLeave
}) => {
  const waterfallRef = useRef<SVGGElement>(null)

  // 計算累積值和每個柱子的位置
  const waterfallData = useMemo(() => {
    if (!data || data.length === 0) return []

    let cumulativeValue = 0
    const processedData: Array<{
      original: WaterfallShapeData
      startValue: number
      endValue: number
      cumulativeValue: number
      isFloating: boolean
    }> = []

    data.forEach((item, _index) => {
      const value = Number(item.value) || 0
      const type = item.type || (value >= 0 ? 'positive' : 'negative')
      
      let startValue: number
      let endValue: number
      let isFloating = false

      switch (type) {
        case 'total':
        case 'subtotal':
          // 總計和小計從 0 開始到累積值
          startValue = 0
          endValue = cumulativeValue + value
          cumulativeValue = endValue
          break
        case 'positive':
        case 'negative':
        default:
          // 正值和負值基於當前累積值
          startValue = cumulativeValue
          endValue = cumulativeValue + value
          cumulativeValue = endValue
          isFloating = true
          break
      }

      processedData.push({
        original: item,
        startValue,
        endValue,
        cumulativeValue,
        isFloating
      })
    })

    return processedData
  }, [data])

  useEffect(() => {
    if (!waterfallRef.current || !waterfallData.length || !xScale || !yScale) return

    const selection = d3.select(waterfallRef.current)
    selection.selectAll('*').remove()

    // 計算柱子寬度
    const bandwidth = xScale.bandwidth ? xScale.bandwidth() : 
      Math.abs(xScale(1) - xScale(0)) * 0.8

    // 繪製連接線
    if (showConnectors && waterfallData.length > 1) {
      const connectorGroup = selection.append('g').attr('class', 'waterfall-connectors')
      
      for (let i = 0; i < waterfallData.length - 1; i++) {
        const current = waterfallData[i]
        const next = waterfallData[i + 1]
        
        if (current.isFloating && next.isFloating) {
          const currentX = xScale.bandwidth ? 
            xScale(current.original.x) + bandwidth :
            xScale(current.original.x)
          const nextX = xScale.bandwidth ? 
            xScale(next.original.x) :
            xScale(next.original.x) - bandwidth / 2
          
          const y = yScale(current.endValue)
          
          connectorGroup
            .append('line')
            .attr('class', 'waterfall-connector')
            .attr('x1', currentX + bandwidth)
            .attr('x2', nextX)
            .attr('y1', y)
            .attr('y2', y)
            .attr('stroke', connectorColor)
            .attr('stroke-width', connectorWidth)
            .attr('stroke-dasharray', connectorDasharray)
            .attr('opacity', animate ? 0 : 0.6)
        }
      }

      if (animate) {
        connectorGroup.selectAll('.waterfall-connector')
          .transition()
          .delay((d, i) => i * 50)
          .duration(animationDuration)
          .attr('opacity', 0.6)
      }
    }

    // 繪製柱子
    const bars = selection
      .selectAll<SVGRectElement, typeof waterfallData[0]>('.waterfall-bar')
      .data(waterfallData, (d, i) => `${d.original.x}-${i}`)

    bars
      .join(
        enter => {
          const enterBars = enter
            .append('rect')
            .attr('class', `waterfall-bar ${className}`)
            .attr('x', d => {
              if (xScale.bandwidth) {
                return xScale(d.original.x)
              } else {
                return xScale(d.original.x) - bandwidth / 2
              }
            })
            .attr('y', d => yScale(Math.max(d.startValue, d.endValue)))
            .attr('width', bandwidth)
            .attr('height', d => Math.abs(yScale(d.startValue) - yScale(d.endValue)))
            .attr('fill', d => {
              const type = d.original.type || (d.original.value >= 0 ? 'positive' : 'negative')
              switch (type) {
                case 'positive': return positiveColor
                case 'negative': return negativeColor
                case 'total': return totalColor
                case 'subtotal': return subtotalColor
                default: return d.original.value >= 0 ? positiveColor : negativeColor
              }
            })
            .attr('stroke', strokeColor)
            .attr('stroke-width', strokeWidth)
            .attr('opacity', animate ? 0 : opacity)

          if (animate) {
            enterBars
              .transition()
              .delay((d, i) => i * 100)
              .duration(animationDuration)
              .attr('opacity', opacity)
          }

          // 添加事件處理
          if (onDataClick || onBarClick || onDataHover || onBarMouseEnter || onBarMouseLeave) {
            enterBars
              .style('cursor', 'pointer')
              .on('click', function(event, d) {
                if (onDataClick) {
                  onDataClick(d.original, d.cumulativeValue, event)
                } else if (onBarClick) {
                  onBarClick(d.original, d.cumulativeValue, event)
                }
              })
              .on('mouseenter', function(event, d) {
                if (onDataHover) {
                  onDataHover(d.original, d.cumulativeValue, event)
                } else if (onBarMouseEnter) {
                  onBarMouseEnter(d.original, d.cumulativeValue, event)
                }
                // 鼠標懸停效果
                d3.select(this)
                  .transition()
                  .duration(150)
                  .attr('opacity', Math.min(1, opacity + 0.2))
              })
              .on('mouseleave', function(event, d) {
                if (onDataHover) {
                  onDataHover(null, d.cumulativeValue, event)
                } else if (onBarMouseLeave) {
                  onBarMouseLeave(d.original, d.cumulativeValue, event)
                }
                // 恢復原始透明度
                d3.select(this)
                  .transition()
                  .duration(150)
                  .attr('opacity', opacity)
              })
          }

          return enterBars
        },
        update => {
          const updateBars = update
            .attr('x', d => {
              if (xScale.bandwidth) {
                return xScale(d.original.x)
              } else {
                return xScale(d.original.x) - bandwidth / 2
              }
            })
            .attr('width', bandwidth)
            .attr('fill', d => {
              const type = d.original.type || (d.original.value >= 0 ? 'positive' : 'negative')
              switch (type) {
                case 'positive': return positiveColor
                case 'negative': return negativeColor
                case 'total': return totalColor
                case 'subtotal': return subtotalColor
                default: return d.original.value >= 0 ? positiveColor : negativeColor
              }
            })

          if (animate) {
            updateBars
              .transition()
              .duration(animationDuration)
              .attr('y', d => yScale(Math.max(d.startValue, d.endValue)))
              .attr('height', d => Math.abs(yScale(d.startValue) - yScale(d.endValue)))
              .attr('opacity', opacity)
          } else {
            updateBars
              .attr('y', d => yScale(Math.max(d.startValue, d.endValue)))
              .attr('height', d => Math.abs(yScale(d.startValue) - yScale(d.endValue)))
              .attr('opacity', opacity)
          }

          return updateBars
        },
        exit => exit
          .call(exit => animate ?
            exit
              .transition()
              .duration(animationDuration)
              .attr('opacity', 0)
              .attr('height', 0)
              .remove()
            :
            exit.remove()
          )
      )

  }, [
    waterfallData,
    xScale,
    yScale,
    className,
    animate,
    animationDuration,
    positiveColor,
    negativeColor,
    totalColor,
    subtotalColor,
    opacity,
    strokeWidth,
    strokeColor,
    showConnectors,
    connectorColor,
    connectorWidth,
    connectorDasharray,
    onDataClick,
    onDataHover,
    onBarClick,
    onBarMouseEnter,
    onBarMouseLeave
  ])

  return (
    <g ref={waterfallRef} className={`waterfall ${className}`} />
  )
}